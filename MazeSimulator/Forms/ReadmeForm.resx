<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="richTextBox1.Text" xml:space="preserve">
    <value>MultiAgent-HyperSharpNEAT Simulator Documentation

MultiAgent-HyperSharpNEAT Simulator v0.5 C#,
By David D'Ambrosio, Joel Lehman, and Sebastian Risi
http://eplex.cs.ucf.edu
ddambro@eecs.ucf.edu, jlehman@eecs.ucf.edu, sebastian.risi@gmail.com

Faculty Supervisor: Kenneth Stanley
kstanley@eecs.ucf.edu

Documentation for this package is included in this README file. 

-------------
1. LICENSE
-------------

Some of this code is from Colin Green's SharpNEAT 1.0 (http://sharpneat.sourceforge.net/).  All original SharpNEAT code is covered by the original SharpNEAT license as described by Colin Green:

"The SharpNeat project consists of the core code packaged as SharpNeatLib and the main application simply called SharpNeat. SharpNeatLib is released under the Gnu Lesser General Public License (LGPL) which means you can link to it from your own programs, proprietory or otherwise. 

The SharpNeat application is released under the Gnu General Public License (GPL).

The additional applications, PreyCaptureSimulator and PoleBalancingSimulator have no license and are public domain. Modify them at your will."

This package contains HyperSharpNEAT which modifies original SharpNEAT 1.0 to implement HyperNEAT and add additional functionality such as Novelty Search.  Additionally it includes a multiagent simulator.

The HyperNEAT additions and simulator are covered by the following license:

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License version 2 as published by the Free Software Foundation (LGPL may be granted upon request). This program is distributed in the hope that it will be useful, but without any warranty; without even the implied warranty of merchantability or fitness for a particular purpose. See the GNU General Public License for more details.

---------------------
2. USAGE and SUPPORT
---------------------

We hope that this software will be a useful starting point for your own explorations in multiagent simulation and neuroevolution. The software is provided as is, however, we will do our best to maintain it and accommodate suggestions. If you want to be notified of future releases of the software or have questions, comments, bug reports or suggestions, send email to one of the authors.

Alternatively, you may post your questions on the NEAT Users Group at : http://tech.groups.yahoo.com/group/neat/.

The following explains how to use the software packages.  For information on compiling, please see the section on compiling below.

INTRO
-----
This package makes use of HyperNEAT, which is an extension of NEAT (NeuroEvolution of Augmenting Topologies) that evolves CPPNs (Compositional Pattern Producing Networks) that encode large-scale neural network connectivity patterns.  A complete explanation of HyperNEAT is available here:

@Article{stanley:alife09,
  author       = "Kenneth O. Stanley and David B. D'Ambrosio and Jason Gauci",
  title        = "A Hypercube-Based Indirect Encoding for Evolving Large-Scale Neural Networks",
  journal      = "Artificial Life",
  volume       = 15,
  number       = 2,
  pages        = "185--212",
  year         = 2009,
  url          = "http://eplex.cs.ucf.edu/papers/stanley_alife09.pdf",
  publisher    = "MIT Press",
  address      = "Cambridge, MA"
}

The version of HyperNEAT distributed in this package executed the experiments in the following paper, with a few alterations:

@InProceedings{dambrosio:aamsa2010,
  author       = "David B. D'Ambrosio and Joel Lehman and Sebastian Risi and Kenneth O. Stanley",
  title        = "Evolving Policy Geometry for Scalable Multiagent Learning",
  booktitle    = "Proceedings of the Ninth International Conference on Autonomous Agents and Multiagent Systems (AAMAS-2010)",
  year         = 2010,
  publisher    = "IFAAMAS: International Foundation for Autonomous Agents and Multiagent Systems",
  site         = "Toronto, Canda",
  url          = "http://eplex.cs.ucf.edu/papers/dambrosio_aamas10.pdf"
}

The version of HyperNEAT distributed in this package also contains an implementation of novelty search, which is described here:

@Article{lehman:ecj10,
 author = “Joel Lehman and Kenneth O. Stanley”,
 title=”Abandoning Objectives: Evolution Through the Search for Novelty Alone”,
 journal=”Evolutionary Computation”,
 publisher= “MIT Press”,
 address = “Cambridge, MA”,
 year= 2010,
 note=”To appear.”,
 url="http://eplex.cs.ucf.edu/papers/lehman_ecj10.pdf"
}

For more information, please visit the EPlex website at:
http://eplex.cs.ucf.edu/

or see more of our publications on HyperNEAT and CPPNs at:
http://eplex.cs.ucf.edu/publications
or 
http://eplex.cs.ucf.edu/hyperNEATpage/HyperNEAT.html

EXECUTABLE
----------
The executable "AgentSimulator.exe" is located in the "release" directory of the same project.  It runs the multiagent room-clearing experiment described below with the parameters in the params.txt file.  Descriptions of how to run the experiment in GUI and commandline mode are included below.

The project files that are included should also allow for easy compilation in Microsoft's Visual Studio.

--------------
3. EXPERIMENTS
--------------

ROOM CLEARING EXPERIMENT
-------------------------
The room-clearing experiment is presented in the 2010 AAMAS paper (see above) .  The
goal of the experiment is for a group of agents to view as much of a room as possible.

When run, the experiment will output the generation number, the fitness, and the amount of time per generation, for each generation.  The experiment will also write out an XML file containing the highest fitness genome whenever a new maximum fitness is reached.

PARAMETER FILE
--------------------------

The main parameters of HyperNEAT can be changed in the included params.txt using this guide:

Threshold .2
WeightRange 3
NumberofThreads 2
SubstrateActivationFunction SteepenedSigmoid
StartActivationFunctions
BipolarSigmoid .25
Sine .25
Gaussian .25
Linear .25
EndActivationFunctions

Threshold defines the minimum value a CPPN must output for that 
connection to be expressed, should be 0-1.

WeightRange defines the minimum and maximum values for weights on substrate
connections, they go from -WeightRange to +WeightRange, and can be any integer.

NumberofThreads defines the number of simultaneous evaluations to run.  
This can be any integer greater than 0, however numbers greater than
the number of cores/processors you have available can degrade performance.  

SubstrateActivationFunction determines which activation function each node
in the substrate will have.  This can be any of the activation functions in 
SharpNEATLib, you can add your own as well.  The activation function is the name of the 
.cs file containing that function (they are accessed by reflection, so case counts).

Activation Functions that can be in the CPPN start with 
"StartActivationFunctions" and are listed one per line and ended with 
"EndActivationFunctions".  Each activation function is the name of the .cs file
containing that function (they are accessed by reflection, so case counts) followed
by the probability of that function appearing.

COMMAND LINE
--------------
If called with the parameter "evolve" the command line tool is used. Otherwise the visual simulator is started.

The available command line parameters:

-experiment [filename]         	//Load this experiment.
-homogenous [true/false]	//If true use homogenous teams otherwise heterogenous
-populationSize [number]
-generations [number]
-agent_count [number]
-novelty                     			//Use novelty search
-fitness_function [filename]
-hidden_density [number]     	//Specifies the number of hidden neurons
-input_density [number]      	//Specifies the number of input neurons
-rng_seed [number]           		//What random seed should be used.
-environment [filename]
-substrate [filename]
-eval [filename]             		//Evaluate the given genome and return fitness
-seed [filename]             		//Seed evolution with the given genome
-folder [name]               			//Outpout files to the specified folder

The command line tool will output genome files whenever a new champion is discovered. These genome files can be viewed in the visualizer.

THE USER INTERFACE
---------------
The MultiAgent-HyperSharpNEAT Simulator GUI has 6 menus: File, Mode, Agents, Experiment, Evolve, and Help.

The File menu allows you to load and save experiments, genomes and environments. Included in this package are representative sample individuals evolved with multi-agent HyperNEAT and a non-multi-agent version of HyperNEAT for comparison (standard HyperNEAT). To run them, you must first load the appropriate experiment file (File-&gt;Load Experiment), then load the genome file (File-&gt;Load Genome). After both the experiment and genome are loaded, you can run the simulation through the Experiment-&gt;Run menu item.

It is important to note that the experiment file contains settings that determine how the genome file is interpreted. Running a genome in the context of an experiment file in which it was not evolved will often cause meaningless behavior. The sample individuals (found in the genomes subdirectory) are named according to which experiment (found in the experiments subdirectory) they should be run with:

roomclearing_heterogeneous_experiment.xml - MultiAgent HyperNEAT experiment file where robots cannot see each other
roomclearing_heterogeneous_samplegenome[0-6].xml - Sample genomes

roomclearing_homogeneous_experiment.xml - Homogeneous HyperNEAT experiment file where robots cannot see each other
roomclearing_homogeneous_samplegenome[0-6].xml - Sample genomes

roomclearing_visible_heterogeneous_experiment.xml - MultiAgent HyperNEAT experiment file where robots can see each other
roomclearing_visible_heterogeneous_samplegenome[0-6].xml - Sample genomes

roomclearing_visible_homogeneous_experiment.xml - Homogeneous HyperNEAT experiment file where robots can see each other
roomclearing_visible_homogeneous_samplegenome[0-6].xml - Sample genomes

The Mode menu allows you to change the current mode. The mode determines how mouse interaction will affect the environment.
Select mode: Agents and walls can be selected and moved to different locations by clicking and dragging with the left mouse button. This can be used as an experiment is running for interactive exploration of the evolved behaviors of the agents. Agents and walls can also be rotated by clicking and dragging with the right mouse button. 
Wall mode: By clicking and dragging with the left mouse button you can create a new wall.
Start Point, Goal Point, Point of Interest (POI), and Area of Interest (AOI) mode: A click on the environment places the corresponding object. The start point indicates where agents will begin in the environment, the goal point and POI (if used by the fitness function) indicate where agents should reach, and the AOI indicates for the room clearing experiment, what area of the environment should be covered by the agents.

The Agents menu allows you to explore the effects of scaling the team size (Agents-&gt;Agent Settings). Scaling to more agents with a homogeneous team (standard HyperNEAT) will add new agents with exactly the same policy, while scaling to more agents with multiagent HyperNEAT will add agents with different policies derived from their initial team geometry. To change the number of rangefinders or add different levels of noise use Agents-&gt;Sensor Configuration.

The Experiment menu allows the user to run or reset the simulation (which will cause the agents to return to their initial starting locations). You can also choose different fitness functions (which will influence what behaviors are rewarded when doing fitness-based evolution) , behavioral characterizations (which define the space of behaviors that novelty search will explore) and robot models. 

The Evolution menu allows you to start evolution and to display the currently best performing genome. The novelty search menu item allows you to toggle between fitness-based search and novelty search. If fitness-based search is used (the novelty search item is not ticked), search will be guided by the chosen fitness function. If novelty search is used, search will depend on the chosen behavioral characterization.

The Help menu offers an overview of the available key commands.
--------------
4. RESULTS
--------------
The original results presented in the AAMAS 2010 paper are no longer compatible with this simulator due to extensive changes in architecture.  Previous results are available on request from ddambro@eecs.ucf.edu.  However, this package includes many example solutions that mirror the results from the AAMAS paper. See the GUI description on how to use the sample evolved individuals.

--------------
5. COMPILING
--------------

DEPENDENCIES
--------------
Everything necessary to compile the MultiAgent-HyperSharpNEAT Simulator is included in this release.

BUILD INSTRUCTIONS:
---------------
UNIX/LINUX/CYGWIN/MACOSX:

To run on these systems, compile and run with the latest version of Mono.

WINDOWS:

The included project files have everything set up to run in Microsoft Visual Studio 2008.

--------------
6. DEMO EXAMPLE
--------------
To quickly get started and see a trained room-clearing team in action, simply take the following steps:
1. Run AgentSimulator.exe
2. Load in the experiment: 
File-&gt;Load Experiment-&gt;roomclearing_heterogeneous_experiment.xml
3. Load in a genome: File-&gt;Load Genome-&gt;roomclearing_heterogeneous_samplegenome0.xml &lt;Find out from Joel which ones are good&gt;
4. Run the simulation: Experiment-&gt;Run
The team should then enter the room and spread out.  The red circles show how much area is viewed by the group.

From there you can experiment with more options such as changing the team size and exploring the team behavior by moving the agents around with your mouse.

--------------
7. FORUM
--------------

We are available to answer questions at the NEAT Users Group:

http://tech.groups.yahoo.com/group/neat/

-------------------
8. ACKNOWLEDGEMENTS 
-------------------

Special thanks to Colin Green for creating SharpNEAT.
This work was supported by DARPA under grants HR0011-08-1-0020 and HR0011-09-1-0045 (Computer Science Study Group Phases I and II).</value>
  </data>
</root>